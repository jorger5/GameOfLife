{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/jrincon/Documents/ Programming/Projects/jRCoding/game-of-life/src/Components/Grid.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useCallback, useRef } from 'react';\nimport produce from 'immer';\nlet numRows = 10;\nlet numCols = 15;\nconst neighborsLoc = [[0, 1], //north\n[1, 1], //north-east\n[1, 0], //east\n[1, -1], //south-east\n[0, -1], //south\n[-1, -1], //south-west\n[-1, 0], //west\n[-1, 1] //northwest\n];\n\nconst clearGrid = () => {\n  const rows = []; //iterate from 0 to numRows (set by user) and for each row, create numCols (also set by user)\n\n  for (let i = 0; i < numRows; i++) {\n    //here we push to row Array using .from method, the length will be numCols and for each one\n    //we map a value of 0 (dead cell state)\n    rows.push(Array.from(Array(numCols), () => 0));\n  }\n\n  return rows;\n};\n\nconst countNeighbors = ([i, j], x, y) => {\n  return neighborsLoc.reduce((acc, [i, j]) => {\n    const row = (x + i + numRows) % numRows;\n    const col = (y + j + numCols) % numCols;\n    acc += grid[row][col];\n    return acc;\n  }, 0);\n};\n\nexport const Grid = () => {\n  _s();\n\n  //to create grid, we use useState hook\n  const [grid, setGrid] = useState(() => {\n    return clearGrid();\n  });\n  const [play, setPlay] = useState(false);\n  const [autoTime, setAutoTime] = useState(1000);\n  const [generation, setGeneration] = useState(0); //useRef to store the value of play and using it on autoGame func\n\n  const playRef = useRef(play);\n  playRef.current = play;\n  const generationRef = useRef(generation);\n  generationRef.current = generation; //useCallback to run autoGame function only once\n\n  const autoGame = useCallback(() => {\n    setInterval(() => {\n      if (!playRef.current) {\n        return;\n      }\n\n      setGrid(currentGrid => produce(currentGrid, gridCopy => {\n        for (let i = 0; i < numRows; i++) {\n          for (let j = 0; j < numCols; j++) {\n            const count = countNeighbors(currentGrid, i, j);\n            if (currentGrid[i][j] === 1 && (count < 2 || count > 3)) gridCopy[i][j] = 0;\n            if (!currentGrid[i][j] && count === 3) gridCopy[i][j] = 1;\n          }\n        }\n      }));\n      setGeneration(++generationRef.current);\n    }, autoTime);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        setPlay(true);\n\n        if (play === false) {\n          playRef.current = true;\n          console.log('corriendo');\n          autoGame();\n        }\n      },\n      children: \"Iniciar\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        setPlay(false);\n      },\n      children: \"Detener \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        setGrid(clearGrid());\n      },\n      children: \"Reiniciar \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      placeholder: \"Introduce tiempo de ejecuci\\xF3n deseado\",\n      onChange: e => setAutoTime(e.target.value)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Juego \", play ? 'Iniciado' : 'Detenido', \" y simulando a \", autoTime]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'grid',\n        gridTemplateColumns: `repeat(${numCols}, 20px)`,\n        columnGap: '5px',\n        rowGap: '5px'\n      },\n      children: grid.map((rows, i) => rows.map((col, j) => /*#__PURE__*/_jsxDEV(\"div\", {\n        onClick: () => {\n          //produce() takes the argument of individual grid, copies it and then mutates it.\n          //\n          const newGrid = produce(grid, gridCopy => {\n            //check if current cell at [i][j] is dead or alive, it toggles the value between them \n            gridCopy[i][j] = grid[i][j] ? 0 : 1;\n          });\n          setGrid(newGrid);\n        },\n        style: {\n          width: 20,\n          height: 20,\n          border: 'solid 1px blue',\n          borderRadius: '100%',\n          backgroundColor: grid[i][j] ? 'green' : ''\n        }\n      }, `${i}-${j}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 17\n      }, this)))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Grid, \"7TnWNdqLcY7bJTnMHU57KKNLTcY=\");\n\n_c = Grid;\n\nvar _c;\n\n$RefreshReg$(_c, \"Grid\");","map":{"version":3,"sources":["/Users/jrincon/Documents/ Programming/Projects/jRCoding/game-of-life/src/Components/Grid.js"],"names":["React","useState","useCallback","useRef","produce","numRows","numCols","neighborsLoc","clearGrid","rows","i","push","Array","from","countNeighbors","j","x","y","reduce","acc","row","col","grid","Grid","setGrid","play","setPlay","autoTime","setAutoTime","generation","setGeneration","playRef","current","generationRef","autoGame","setInterval","currentGrid","gridCopy","count","console","log","e","target","value","display","gridTemplateColumns","columnGap","rowGap","map","newGrid","width","height","border","borderRadius","backgroundColor"],"mappings":"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","sourcesContent":["import React, { useState, useCallback, useRef } from 'react';\nimport produce from 'immer';\n\n\nlet numRows = 10;\nlet numCols = 15;\n\nconst neighborsLoc = [\n    [0, 1], //north\n    [1, 1], //north-east\n    [1, 0], //east\n    [1, -1], //south-east\n    [0, -1], //south\n    [-1, -1], //south-west\n    [-1, 0], //west\n    [-1, 1] //northwest\n];\n\nconst clearGrid = () => {\n    const rows = [];\n    //iterate from 0 to numRows (set by user) and for each row, create numCols (also set by user)\n    for (let i = 0; i < numRows; i++) {\n        //here we push to row Array using .from method, the length will be numCols and for each one\n        //we map a value of 0 (dead cell state)\n        rows.push(Array.from(Array(numCols), () => 0 ));\n    }\n    return rows;\n};\n\nconst countNeighbors = ([i, j], x , y) => {\n    return neighborsLoc.reduce((acc, [i, j]) => {\n      const row = (x + i + numRows) % numRows;\n      const col = (y + j + numCols) % numCols;\n      acc += grid[row][col];\n      return acc;\n    }, 0);\n  };\n\nexport const Grid = () => {\n    //to create grid, we use useState hook\n    const [grid, setGrid] = useState(() => {\n        return clearGrid();\n    });\n\n    const [play, setPlay] = useState(false);\n    const [autoTime, setAutoTime] = useState(1000);\n    const [generation, setGeneration] = useState(0);\n\n    //useRef to store the value of play and using it on autoGame func\n    const playRef = useRef(play);\n    playRef.current = play;\n    \n    const generationRef = useRef(generation);\n    generationRef.current = generation;\n\n    //useCallback to run autoGame function only once\n    const autoGame = useCallback(() => {\n        setInterval(() => {\n\n        if(!playRef.current) {\n            return;\n        }\n\n      setGrid((currentGrid) =>\n        produce(currentGrid, (gridCopy) => {\n          for (let i = 0; i < numRows; i++) {\n            for (let j = 0; j < numCols; j++) {\n              const count = countNeighbors(currentGrid, i, j);\n              if (currentGrid[i][j] === 1 && (count < 2 || count > 3))\n                gridCopy[i][j] = 0;\n              if (!currentGrid[i][j] && count === 3) gridCopy[i][j] = 1;\n            }\n          }\n        }),\n      );\n      setGeneration(++generationRef.current);\n        }, autoTime);\n    },[])\n\n    return (\n        <>\n        <button onClick={()=>{\n            setPlay(true);\n            if(play === false){\n                playRef.current = true;\n                console.log('corriendo');\n                autoGame();\n            }\n\n        }} >Iniciar</button>\n        <button onClick={()=>{\n            setPlay(false);\n        }} >Detener </button>\n\n        <button onClick={()=>{\n            setGrid(clearGrid());\n        }} >Reiniciar </button>\n\n        <input\n        placeholder='Introduce tiempo de ejecución deseado'\n        onChange={e => setAutoTime(e.target.value)}\n        />\n\n        <p>Juego {play ? 'Iniciado' : 'Detenido'} y simulando a {autoTime}</p>\n        \n        <div style={{\n            display: 'grid',\n            gridTemplateColumns: `repeat(${numCols}, 20px)`,\n            columnGap: '5px',\n            rowGap: '5px'\n        }}>\n            {grid.map ((rows, i) =>\n                rows.map( (col, j) => \n                <div \n                    key={`${i}-${j}`}\n                    onClick={()=>{\n                        //produce() takes the argument of individual grid, copies it and then mutates it.\n                        //\n                        const newGrid = produce(grid, gridCopy => {\n                            //check if current cell at [i][j] is dead or alive, it toggles the value between them \n                            gridCopy[i][j] = grid[i][j] ? 0 : 1;\n                        });\n                    setGrid(newGrid);\n                }} \n                style={{ \n                    width:20, \n                    height:20, \n                    border: 'solid 1px blue',\n                    borderRadius: '100%', \n                    backgroundColor: grid[i][j] ? 'green' : ''}} />\n                ))}\n        </div>\n        </>\n    )\n};\n\n\n"]},"metadata":{},"sourceType":"module"}